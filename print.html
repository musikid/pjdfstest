<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>PJDFSTest</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="introduction.html">Introduction</a></li><li class="chapter-item expanded affix "><li class="part-title">Running tests</li><li class="chapter-item expanded "><a href="getting-started.html"><strong aria-hidden="true">1.</strong> Getting started</a></li><li class="chapter-item expanded "><a href="compatibility.html"><strong aria-hidden="true">2.</strong> Compatibility</a></li><li class="chapter-item expanded "><a href="configuration-file.html"><strong aria-hidden="true">3.</strong> Configuration file</a></li><li class="chapter-item expanded affix "><li class="part-title">Writing tests</li><li class="chapter-item expanded "><a href="tests-structure.html"><strong aria-hidden="true">4.</strong> Structure</a></li><li class="chapter-item expanded "><a href="test-declaration.html"><strong aria-hidden="true">5.</strong> Declaration</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">PJDFSTest</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/saidsay-so/pjdfstest" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p>PJDFSTest is a file system test suite focused on POSIX compliance,
primarily for FreeBSD file systems.
It was originally written to validate the ZFS port to FreeBSD,
but it now supports multiple operating systems and file systems.</p>
<p>This is a complete rewrite of the original test suite in Rust,
as part of the Google Summer of Code 2022 program
(<a href="https://summerofcode.withgoogle.com/archive/2022/projects/6XPYWLzJ">https://summerofcode.withgoogle.com/archive/2022/projects/6XPYWLzJ</a>).</p>
<p><strong>NOTE: The documentation is still a work-in-progress</strong></p>
<h2 id="build"><a class="header" href="#build">Build</a></h2>
<pre><code class="language-bash">cd rust
cargo run
</code></pre>
<h3 id="run-as-root"><a class="header" href="#run-as-root">Run as root</a></h3>
<pre><code class="language-bash">cd rust
cargo build &amp;&amp; sudo ./target/debug/pjdfstest
</code></pre>
<h2 id="contributing"><a class="header" href="#contributing">Contributing</a></h2>
<p>Please read the <a href="CONTRIBUTING.html">CONTRIBUTING.md</a> file on how to contribute to this project.
In addition to this book, you can also find the crate documentation by running <code>cargo doc --open</code>
in the <code>rust</code> directory or by visiting the <a href="/doc/pjdfstest">documentation</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="getting-started"><a class="header" href="#getting-started">Getting started</a></h1>
<p>The test suite is as file system agnostic as possible
and tries to comply with the POSIX specification.
Typically, tests which make use of non-POSIX features
are opt-in and only tests for syscalls which must be available on every POSIX system are ran.
It can be configured with the configuration file, by specifying additional features
supported by the file system/operating system.</p>
<h2 id="command-line-interface"><a class="header" href="#command-line-interface">Command-line interface</a></h2>
<p><em><code>pjdfstest [OPTIONS] [--] TEST_PATTERNS</code></em></p>
<ul>
<li><code>-h, --help</code> - Print help message</li>
<li><code>-c, --configuration-file CONFIGURATION-FILE</code> - Path of the configuration file</li>
<li><code>-l, --list-features</code> - List opt-in features</li>
<li><code>-e, --exact</code> - Match names exactly</li>
<li><code>-v, --verbose</code> - Verbose mode</li>
<li><code>-p, --path PATH</code> - Path where the test suite will be executed</li>
<li><code>[--] TEST_PATTERNS</code> - Filter tests which match against the provided patterns</li>
</ul>
<p>Example: <code>pjdfstest -c pjdfstest.toml chmod</code></p>
<h2 id="filter-tests"><a class="header" href="#filter-tests">Filter tests</a></h2>
<p>It is possible to filter which tests should be run by specifying which parts should match.
Tests are usually identified by syscall and optionally the file type on which it operates.</p>
<h2 id="rootless-running"><a class="header" href="#rootless-running">Rootless running</a></h2>
<p>The test suite can be run without privileges.
However, not all tests can be completed without privileges,
therefore the coverage will be incomplete.
For example, tests which need to switch users will not be run.</p>
<h2 id="dummy-usersgroups"><a class="header" href="#dummy-usersgroups">Dummy users/groups</a></h2>
<p>The test suite needs dummy users and groups to be set up.
This should be handled automatically when installing it via a package,
but they need to be created otherwise.
By default, the users (with the same name for the group associated to each of them) to create are:</p>
<ul>
<li>nobody</li>
<li>tests</li>
<li>pjdfstest</li>
</ul>
<p>It is also possible to specify other users with the configuration file.</p>
<h3 id="create-users"><a class="header" href="#create-users">Create users</a></h3>
<h4 id="freebsd"><a class="header" href="#freebsd">FreeBSD</a></h4>
<pre><code class="language-bash">cat &lt;&lt;EOF | adduser -w none -S -f -
pjdfstest::::::Dummy User for pjdfstest:/nonexistent:/sbin/nologin:
EOF
</code></pre>
<h4 id="linux"><a class="header" href="#linux">Linux</a></h4>
<pre><code class="language-bash">cat &lt;&lt;EOF | newusers
tests:x:::Dummy User for pjdfstest:/:/usr/bin/nologin
pjdfstest:x:::Dummy User for pjdfstest:/:/usr/bin/nologin
EOF
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="compatibility"><a class="header" href="#compatibility">Compatibility</a></h1>
<p>The test suite is designed to be compatible with multiple operating systems and file systems.
It is primarily focused on POSIX compliance for FreeBSD file systems, but is also compatible with other operating systems and file systems
in addition of supplementary tests.</p>
<h2 id="supported-operating-systems"><a class="header" href="#supported-operating-systems">Supported operating systems</a></h2>
<h3 id="active-support"><a class="header" href="#active-support">Active support</a></h3>
<p>The test suite has been tested and is actively maintained on the following operating systems:</p>
<ul>
<li>FreeBSD (main development platform)
<ul>
<li>UFS</li>
<li>ZFS</li>
</ul>
</li>
<li>Linux
<ul>
<li>ext4</li>
</ul>
</li>
</ul>
<h3 id="experimental-support"><a class="header" href="#experimental-support">Experimental support</a></h3>
<p>The test suite has not been tested on the following operating systems, but should work:</p>
<ul>
<li>MacOS</li>
<li>NetBSD</li>
<li>OpenBSD</li>
<li>Solaris</li>
<li>DragonFly BSD</li>
<li>Illumos</li>
<li>Android</li>
<li>iOS</li>
</ul>
<h2 id="missing-tests"><a class="header" href="#missing-tests">Missing tests</a></h2>
<p>The test suite is a complete rewrite of the original test suite in Rust. Many tests have been ported, but some tests are still missing.</p>
<details>
<summary>chflags <progress value='9' max='14'></progress></summary>
<table>
<tr>
<th>Test</th>
<th>Description</th>
<th>Converted</th>
</tr>
<tr>
<td>00.t</td>
<td>chflags changes flags
</td>
<td>Yes</td>
</tr>
<tr>
<td>01.t</td>
<td>chflags returns ENOTDIR if a component of the path prefix is not a directory
</td>
<td>Yes</td>
</tr>
<tr>
<td>02.t</td>
<td>chflags returns ENAMETOOLONG if a component of a pathname exceeded {NAME_MAX} characters
</td>
<td>Yes</td>
</tr>
<tr>
<td>03.t</td>
<td>chflags returns ENAMETOOLONG if an entire path name exceeded {PATH_MAX} characters
</td>
<td>Yes</td>
</tr>
<tr>
<td>04.t</td>
<td>chflags returns ENOENT if the named file does not exist
</td>
<td>Yes</td>
</tr>
<tr>
<td>05.t</td>
<td>chflags returns EACCES when search permission is denied for a component of the path prefix
</td>
<td>No</td>
</tr>
<tr>
<td>06.t</td>
<td>chflags returns ELOOP if too many symbolic links were encountered in translating the pathname
</td>
<td>Yes</td>
</tr>
<tr>
<td>07.t</td>
<td>chflags returns EPERM when the effective user ID does not match the owner of the file and the effective user ID is not the super-user
</td>
<td>No</td>
</tr>
<tr>
<td>08.t</td>
<td>chflags returns EPERM when one of SF_IMMUTABLE, SF_APPEND, or SF_NOUNLINK is set and the user is not the super-user
</td>
<td>No</td>
</tr>
<tr>
<td>09.t</td>
<td>chflags returns EPERM when one of SF_IMMUTABLE, SF_APPEND, or SF_NOUNLINK is set and securelevel is greater than 0
</td>
<td>Yes</td>
</tr>
<tr>
<td>10.t</td>
<td>chflags returns EPERM if non-super-user tries to set one of SF_IMMUTABLE, SF_APPEND, or SF_NOUNLINK
</td>
<td>No</td>
</tr>
<tr>
<td>11.t</td>
<td>chflags returns EPERM if a user tries to set or remove the SF_SNAPSHOT flag
</td>
<td>No</td>
</tr>
<tr>
<td>12.t</td>
<td>chflags returns EROFS if the named file resides on a read-only file system
</td>
<td>Yes</td>
</tr>
<tr>
<td>13.t</td>
<td>chflags returns EFAULT if the path argument points outside the process's allocated address space
</td>
<td>Yes</td>
</tr>
</table>
</details>
<details>
<summary>chmod <progress value='9' max='13'></progress></summary>
<table>
<tr>
<th>Test</th>
<th>Description</th>
<th>Converted</th>
</tr>
<tr>
<td>00.t</td>
<td>chmod changes permission
</td>
<td>Yes</td>
</tr>
<tr>
<td>01.t</td>
<td>chmod returns ENOTDIR if a component of the path prefix is not a directory
</td>
<td>Yes</td>
</tr>
<tr>
<td>02.t</td>
<td>chmod returns ENAMETOOLONG if a component of a pathname exceeded {NAME_MAX} characters
</td>
<td>Yes</td>
</tr>
<tr>
<td>03.t</td>
<td>chmod returns ENAMETOOLONG if an entire path name exceeded {PATH_MAX} characters
</td>
<td>Yes</td>
</tr>
<tr>
<td>04.t</td>
<td>chmod returns ENOENT if the named file does not exist
</td>
<td>Yes</td>
</tr>
<tr>
<td>05.t</td>
<td>chmod returns EACCES when search permission is denied for a component of the path prefix
</td>
<td>No</td>
</tr>
<tr>
<td>06.t</td>
<td>chmod returns ELOOP if too many symbolic links were encountered in translating the pathname
</td>
<td>Yes</td>
</tr>
<tr>
<td>07.t</td>
<td>chmod returns EPERM if the operation would change the ownership, but the effective user ID is not the super-user
</td>
<td>No</td>
</tr>
<tr>
<td>08.t</td>
<td>chmod returns EPERM if the named file has its immutable or append-only flag set
</td>
<td>No</td>
</tr>
<tr>
<td>09.t</td>
<td>chmod returns EROFS if the named file resides on a read-only file system
</td>
<td>Yes</td>
</tr>
<tr>
<td>10.t</td>
<td>chmod returns EFAULT if the path argument points outside the process's allocated address space
</td>
<td>Yes</td>
</tr>
<tr>
<td>11.t</td>
<td>chmod returns EFTYPE if the effective user ID is not the super-user, the mode includes the sticky bit (S_ISVTX), and path does not refer to a directory
</td>
<td>Yes</td>
</tr>
<tr>
<td>12.t</td>
<td>verify SUID/SGID bit behaviour
</td>
<td>No</td>
</tr>
</table>
</details>
<details>
<summary>chown <progress value='7' max='11'></progress></summary>
<table>
<tr>
<th>Test</th>
<th>Description</th>
<th>Converted</th>
</tr>
<tr>
<td>00.t</td>
<td>chown changes ownership
</td>
<td>No</td>
</tr>
<tr>
<td>01.t</td>
<td>chown returns ENOTDIR if a component of the path prefix is not a directory
</td>
<td>Yes</td>
</tr>
<tr>
<td>02.t</td>
<td>chown returns ENAMETOOLONG if a component of a pathname exceeded ${NAME_MAX} characters
</td>
<td>Yes</td>
</tr>
<tr>
<td>03.t</td>
<td>chown returns ENAMETOOLONG if an entire path name exceeded {PATH_MAX} characters
</td>
<td>Yes</td>
</tr>
<tr>
<td>04.t</td>
<td>chown returns ENOENT if the named file does not exist
</td>
<td>Yes</td>
</tr>
<tr>
<td>05.t</td>
<td>chown returns EACCES when search permission is denied for a component of the path prefix
</td>
<td>No</td>
</tr>
<tr>
<td>06.t</td>
<td>chown returns ELOOP if too many symbolic links were encountered in translating the pathname
</td>
<td>Yes</td>
</tr>
<tr>
<td>07.t</td>
<td>chown returns EPERM if the operation would change the ownership, but the effective user ID is not the super-user and the process is not an owner of the file
</td>
<td>No</td>
</tr>
<tr>
<td>08.t</td>
<td>chown returns EPERM if the named file has its immutable or append-only flag set
</td>
<td>No</td>
</tr>
<tr>
<td>09.t</td>
<td>chown returns EROFS if the named file resides on a read-only file system
</td>
<td>Yes</td>
</tr>
<tr>
<td>10.t</td>
<td>chown returns EFAULT if the path argument points outside the process's allocated address space
</td>
<td>Yes</td>
</tr>
</table>
</details>
<details>
<summary>ftruncate <progress value='2' max='15'></progress></summary>
<table>
<tr>
<th>Test</th>
<th>Description</th>
<th>Converted</th>
</tr>
<tr>
<td>00.t</td>
<td>ftruncate descrease/increase file size
</td>
<td>Yes</td>
</tr>
<tr>
<td>01.t</td>
<td>truncate returns ENOTDIR if a component of the path prefix is not a directory
</td>
<td>No</td>
</tr>
<tr>
<td>02.t</td>
<td>truncate returns ENAMETOOLONG if a component of a pathname exceeded {NAME_MAX} characters
</td>
<td>No</td>
</tr>
<tr>
<td>03.t</td>
<td>truncate returns ENAMETOOLONG if an entire path name exceeded {PATH_MAX} characters
</td>
<td>No</td>
</tr>
<tr>
<td>04.t</td>
<td>truncate returns ENOENT if the named file does not exist
</td>
<td>No</td>
</tr>
<tr>
<td>05.t</td>
<td>truncate returns EACCES when search permission is denied for a component of the path prefix
</td>
<td>No</td>
</tr>
<tr>
<td>06.t</td>
<td>truncate returns EACCES if the named file is not writable by the user
</td>
<td>No</td>
</tr>
<tr>
<td>07.t</td>
<td>truncate returns ELOOP if too many symbolic links were encountered in translating the pathname
</td>
<td>No</td>
</tr>
<tr>
<td>08.t</td>
<td>truncate returns EPERM if the named file has its immutable or append-only flag set
</td>
<td>No</td>
</tr>
<tr>
<td>09.t</td>
<td>truncate returns EISDIR if the named file is a directory
</td>
<td>No</td>
</tr>
<tr>
<td>10.t</td>
<td>truncate returns EROFS if the named file resides on a read-only file system
</td>
<td>No</td>
</tr>
<tr>
<td>11.t</td>
<td>truncate returns ETXTBSY the file is a pure procedure (shared text) file that is being executed
</td>
<td>No</td>
</tr>
<tr>
<td>12.t</td>
<td>truncate returns EFBIG or EINVAL if the length argument was greater than the maximum file size
</td>
<td>No</td>
</tr>
<tr>
<td>13.t</td>
<td>ftruncate returns EINVAL if the length argument was less than 0
</td>
<td>Yes</td>
</tr>
<tr>
<td>14.t</td>
<td>truncate returns EFAULT if the path argument points outside the process's allocated address space
</td>
<td>No</td>
</tr>
</table>
</details>
<details>
<summary>granular <progress value='7' max='7'></progress></summary>
<table>
<tr>
<th>Test</th>
<th>Description</th>
<th>Converted</th>
</tr>
<tr>
<td>00.t</td>
<td>NFSv4 granular permissions checking - WRITE_DATA vs APPEND_DATA on directories
</td>
<td>Yes</td>
</tr>
<tr>
<td>01.t</td>
<td>NFSv4 granular permissions checking - ACL_READ_ATTRIBUTES and ACL_WRITE_ATTRIBUTES
</td>
<td>Yes</td>
</tr>
<tr>
<td>02.t</td>
<td>NFSv4 granular permissions checking - ACL_READ_ACL and ACL_WRITE_ACL
</td>
<td>Yes</td>
</tr>
<tr>
<td>03.t</td>
<td>NFSv4 granular permissions checking - DELETE and DELETE_CHILD
</td>
<td>Yes</td>
</tr>
<tr>
<td>04.t</td>
<td>NFSv4 granular permissions checking - ACL_WRITE_OWNER
</td>
<td>Yes</td>
</tr>
<tr>
<td>05.t</td>
<td>NFSv4 granular permissions checking - DELETE and DELETE_CHILD with directories
</td>
<td>Yes</td>
</tr>
<tr>
<td>06.t</td>
<td>NFSv4 granular permissions checking - setuid and setgid are cleared when non-owner calls chown
</td>
<td>Yes</td>
</tr>
</table>
</details>
<details>
<summary>link <progress value='15' max='18'></progress></summary>
<table>
<tr>
<th>Test</th>
<th>Description</th>
<th>Converted</th>
</tr>
<tr>
<td>00.t</td>
<td>link creates hardlinks
</td>
<td>Yes</td>
</tr>
<tr>
<td>01.t</td>
<td>link returns ENOTDIR if a component of either path prefix is not a directory
</td>
<td>Yes</td>
</tr>
<tr>
<td>02.t</td>
<td>link returns ENAMETOOLONG if a component of either pathname exceeded {NAME_MAX} characters
</td>
<td>Yes</td>
</tr>
<tr>
<td>03.t</td>
<td>link returns ENAMETOOLONG if an entire length of either path name exceeded {PATH_MAX} characters
</td>
<td>Yes</td>
</tr>
<tr>
<td>04.t</td>
<td>link returns ENOENT if a component of either path prefix does not exist
</td>
<td>Yes</td>
</tr>
<tr>
<td>05.t</td>
<td>link returns EMLINK if the link count of the file named by name1 would exceed 32767
</td>
<td>Yes</td>
</tr>
<tr>
<td>06.t</td>
<td>link returns EACCES when a component of either path prefix denies search permission
</td>
<td>No</td>
</tr>
<tr>
<td>07.t</td>
<td>link returns EACCES when the requested link requires writing in a directory with a mode that denies write permission
</td>
<td>Yes</td>
</tr>
<tr>
<td>08.t</td>
<td>link returns ELOOP if too many symbolic links were encountered in translating one of the pathnames
</td>
<td>Yes</td>
</tr>
<tr>
<td>09.t</td>
<td>link returns ENOENT if the source file does not exist
</td>
<td>Yes</td>
</tr>
<tr>
<td>10.t</td>
<td>link returns EEXIST if the destination file does exist
</td>
<td>Yes</td>
</tr>
<tr>
<td>11.t</td>
<td>link returns EPERM if the source file is a directory
</td>
<td>No</td>
</tr>
<tr>
<td>12.t</td>
<td>link returns EPERM if the source file has its immutable or append-only flag set
</td>
<td>Yes</td>
</tr>
<tr>
<td>13.t</td>
<td>link returns EPERM if the parent directory of the destination file has its immutable flag set
</td>
<td>Yes</td>
</tr>
<tr>
<td>14.t</td>
<td>link returns EXDEV if the source and the destination files are on different file systems
</td>
<td>Yes</td>
</tr>
<tr>
<td>15.t</td>
<td>link returns ENOSPC if the directory in which the entry for the new link is being placed cannot be extended because there is no space left on the file system containing the directory
</td>
<td>No</td>
</tr>
<tr>
<td>16.t</td>
<td>link returns EROFS if the requested link requires writing in a directory on a read-only file system
</td>
<td>Yes</td>
</tr>
<tr>
<td>17.t</td>
<td>link returns EFAULT if one of the pathnames specified is outside the process's allocated address space
</td>
<td>Yes</td>
</tr>
</table>
</details>
<details>
<summary>mkdir <progress value='9' max='13'></progress></summary>
<table>
<tr>
<th>Test</th>
<th>Description</th>
<th>Converted</th>
</tr>
<tr>
<td>00.t</td>
<td>mkdir creates directories
</td>
<td>Yes</td>
</tr>
<tr>
<td>01.t</td>
<td>mkdir returns ENOTDIR if a component of the path prefix is not a directory
</td>
<td>Yes</td>
</tr>
<tr>
<td>02.t</td>
<td>mkdir returns ENAMETOOLONG if a component of a pathname exceeded {NAME_MAX} characters
</td>
<td>Yes</td>
</tr>
<tr>
<td>03.t</td>
<td>mkdir returns ENAMETOOLONG if an entire path name exceeded {PATH_MAX} characters
</td>
<td>Yes</td>
</tr>
<tr>
<td>04.t</td>
<td>mkdir returns ENOENT if a component of the path prefix does not exist
</td>
<td>Yes</td>
</tr>
<tr>
<td>05.t</td>
<td>mkdir returns EACCES when search permission is denied for a component of the path prefix
</td>
<td>No</td>
</tr>
<tr>
<td>06.t</td>
<td>mkdir returns EACCES when write permission is denied on the parent directory of the directory to be created
</td>
<td>No</td>
</tr>
<tr>
<td>07.t</td>
<td>mkdir returns ELOOP if too many symbolic links were encountered in translating the pathname
</td>
<td>Yes</td>
</tr>
<tr>
<td>08.t</td>
<td>mkdir returns EPERM if the parent directory of the directory to be created has its immutable flag set
</td>
<td>No</td>
</tr>
<tr>
<td>09.t</td>
<td>mkdir returns EROFS if the named file resides on a read-only file system
</td>
<td>Yes</td>
</tr>
<tr>
<td>10.t</td>
<td>mkdir returns EEXIST if the named file exists
</td>
<td>Yes</td>
</tr>
<tr>
<td>11.t</td>
<td>mkdir returns ENOSPC if there are no free inodes on the file system on which the directory is being created
</td>
<td>No</td>
</tr>
<tr>
<td>12.t</td>
<td>mkdir returns EFAULT if the path argument points outside the process's allocated address space
</td>
<td>Yes</td>
</tr>
</table>
</details>
<details>
<summary>mkfifo <progress value='9' max='13'></progress></summary>
<table>
<tr>
<th>Test</th>
<th>Description</th>
<th>Converted</th>
</tr>
<tr>
<td>00.t</td>
<td>mkfifo creates fifo files
</td>
<td>Yes</td>
</tr>
<tr>
<td>01.t</td>
<td>mkfifo returns ENOTDIR if a component of the path prefix is not a directory
</td>
<td>Yes</td>
</tr>
<tr>
<td>02.t</td>
<td>mkfifo returns ENAMETOOLONG if a component of a pathname exceeded {NAME_MAX} characters
</td>
<td>Yes</td>
</tr>
<tr>
<td>03.t</td>
<td>mkfifo returns ENAMETOOLONG if an entire path name exceeded {PATH_MAX} characters
</td>
<td>Yes</td>
</tr>
<tr>
<td>04.t</td>
<td>mkfifo returns ENOENT if a component of the path prefix does not exist
</td>
<td>Yes</td>
</tr>
<tr>
<td>05.t</td>
<td>mkfifo returns EACCES when search permission is denied for a component of the path prefix
</td>
<td>No</td>
</tr>
<tr>
<td>06.t</td>
<td>mkfifo returns EACCES when write permission is denied on the parent directory of the file to be created
</td>
<td>No</td>
</tr>
<tr>
<td>07.t</td>
<td>mkfifo returns ELOOP if too many symbolic links were encountered in translating the pathname
</td>
<td>Yes</td>
</tr>
<tr>
<td>08.t</td>
<td>mkfifo returns EROFS if the named file resides on a read-only file system
</td>
<td>Yes</td>
</tr>
<tr>
<td>09.t</td>
<td>mkfifo returns EEXIST if the named file exists
</td>
<td>Yes</td>
</tr>
<tr>
<td>10.t</td>
<td>mkfifo returns EPERM if the parent directory of the file to be created has its immutable flag set
</td>
<td>No</td>
</tr>
<tr>
<td>11.t</td>
<td>mkfifo returns ENOSPC if there are no free inodes on the file system on which the file is being created
</td>
<td>No</td>
</tr>
<tr>
<td>12.t</td>
<td>mkfifo returns EFAULT if the path argument points outside the process's allocated address space
</td>
<td>Yes</td>
</tr>
</table>
</details>
<details>
<summary>mknod <progress value='9' max='12'></progress></summary>
<table>
<tr>
<th>Test</th>
<th>Description</th>
<th>Converted</th>
</tr>
<tr>
<td>00.t</td>
<td>mknod creates fifo files
</td>
<td>Yes</td>
</tr>
<tr>
<td>01.t</td>
<td>mknod returns ENOTDIR if a component of the path prefix is not a directory
</td>
<td>Yes</td>
</tr>
<tr>
<td>02.t</td>
<td>mknod returns ENAMETOOLONG if a component of a pathname exceeded {NAME_MAX} characters
</td>
<td>Yes</td>
</tr>
<tr>
<td>03.t</td>
<td>mknod returns ENAMETOOLONG if an entire path name exceeded {PATH_MAX} characters
</td>
<td>Yes</td>
</tr>
<tr>
<td>04.t</td>
<td>mknod returns ENOENT if a component of the path prefix does not exist
</td>
<td>Yes</td>
</tr>
<tr>
<td>05.t</td>
<td>mknod returns EACCES when search permission is denied for a component of the path prefix
</td>
<td>No</td>
</tr>
<tr>
<td>06.t</td>
<td>mknod returns EACCES when write permission is denied on the parent directory of the file to be created
</td>
<td>No</td>
</tr>
<tr>
<td>07.t</td>
<td>mknod returns ELOOP if too many symbolic links were encountered in translating the pathname
</td>
<td>Yes</td>
</tr>
<tr>
<td>08.t</td>
<td>mknod returns EEXIST if the named file exists
</td>
<td>Yes</td>
</tr>
<tr>
<td>09.t</td>
<td>mknod returns EPERM if the parent directory of the file to be created has its immutable flag set
</td>
<td>No</td>
</tr>
<tr>
<td>10.t</td>
<td>mknod returns EFAULT if the path argument points outside the process's allocated address space
</td>
<td>Yes</td>
</tr>
<tr>
<td>11.t</td>
<td>mknod creates device files
</td>
<td>Yes</td>
</tr>
</table>
</details>
<details>
<summary>open <progress value='17' max='26'></progress></summary>
<table>
<tr>
<th>Test</th>
<th>Description</th>
<th>Converted</th>
</tr>
<tr>
<td>00.t</td>
<td>open opens (and eventually creates) a file
</td>
<td>Yes</td>
</tr>
<tr>
<td>01.t</td>
<td>open returns ENOTDIR if a component of the path prefix is not a directory
</td>
<td>No</td>
</tr>
<tr>
<td>02.t</td>
<td>open returns ENAMETOOLONG if a component of a pathname exceeded {NAME_MAX} characters
</td>
<td>Yes</td>
</tr>
<tr>
<td>03.t</td>
<td>open returns ENAMETOOLONG if an entire path name exceeded ${PATH_MAX} characters
</td>
<td>Yes</td>
</tr>
<tr>
<td>04.t</td>
<td>open returns ENOENT if a component of the path name that must exist does not exist or O_CREAT is not set and the named file does not exist
</td>
<td>Yes</td>
</tr>
<tr>
<td>05.t</td>
<td>open returns EACCES when search permission is denied for a component of the path prefix
</td>
<td>No</td>
</tr>
<tr>
<td>06.t</td>
<td>open returns EACCES when the required permissions (for reading and/or writing) are denied for the given flags
</td>
<td>No</td>
</tr>
<tr>
<td>07.t</td>
<td>open returns EACCES when O_TRUNC is specified and write permission is denied
</td>
<td>No</td>
</tr>
<tr>
<td>08.t</td>
<td>open returns EACCES when O_CREAT is specified, the file does not exist, and the directory in which it is to be created does not permit writing
</td>
<td>No</td>
</tr>
<tr>
<td>09.t</td>
<td>O_CREAT is specified, the file does not exist, and the directory in which it is to be created has its immutable flag set
</td>
<td>No</td>
</tr>
<tr>
<td>10.t</td>
<td>open returns EPERM when the named file has its immutable flag set and the file is to be modified
</td>
<td>No</td>
</tr>
<tr>
<td>11.t</td>
<td>open returns EPERM when the named file has its append-only flag set, the file is to be modified, and O_TRUNC is specified or O_APPEND is not specified
</td>
<td>No</td>
</tr>
<tr>
<td>12.t</td>
<td>open returns ELOOP if too many symbolic links were encountered in translating the pathname
</td>
<td>Yes</td>
</tr>
<tr>
<td>13.t</td>
<td>open returns EISDIR when trying to open a directory for writing
</td>
<td>Yes</td>
</tr>
<tr>
<td>14.t</td>
<td>open returns EROFS if the named file resides on a read-only file system, and the file is to be modified
</td>
<td>Yes</td>
</tr>
<tr>
<td>15.t</td>
<td>open returns EROFS when O_CREAT is specified and the named file would reside on a read-only file system
</td>
<td>Yes</td>
</tr>
<tr>
<td>16.t</td>
<td>open returns $error when O_NOFOLLOW was specified and the target is a symbolic link
</td>
<td>Yes</td>
</tr>
<tr>
<td>17.t</td>
<td>open returns ENXIO when O_NONBLOCK is set, the named file is a fifo, O_WRONLY is set, and no process has the file open for reading
</td>
<td>Yes</td>
</tr>
<tr>
<td>18.t</td>
<td>open returns EWOULDBLOCK when O_NONBLOCK and one of O_SHLOCK or O_EXLOCK is specified and the file is locked
</td>
<td>Yes</td>
</tr>
<tr>
<td>19.t</td>
<td>open returns ENOSPC when O_CREAT is specified, the file does not exist, and there are no free inodes on the file system on which the file is being created
</td>
<td>No</td>
</tr>
<tr>
<td>20.t</td>
<td>open returns ETXTBSY when the file is a pure procedure (shared text) file that is being executed and the open() system call requests write access
</td>
<td>Yes</td>
</tr>
<tr>
<td>21.t</td>
<td>open returns EFAULT if the path argument points outside the process's allocated address space
</td>
<td>Yes</td>
</tr>
<tr>
<td>22.t</td>
<td>open returns EEXIST when O_CREAT and O_EXCL were specified and the file exists
</td>
<td>Yes</td>
</tr>
<tr>
<td>23.t</td>
<td>open may return EINVAL when an attempt was made to open a descriptor with an illegal combination of O_RDONLY, O_WRONLY, and O_RDWR
</td>
<td>Yes</td>
</tr>
<tr>
<td>24.t</td>
<td>open returns $expected_error when trying to open UNIX domain socket
</td>
<td>Yes</td>
</tr>
<tr>
<td>25.t</td>
<td>interact with > 2 GB files
</td>
<td>Yes</td>
</tr>
</table>
</details>
<details>
<summary>posix_fallocate <progress value='1' max='1'></progress></summary>
<table>
<tr>
<th>Test</th>
<th>Description</th>
<th>Converted</th>
</tr>
<tr>
<td>00.t</td>
<td>posix_fallocate descrease/increase file size
</td>
<td>Yes</td>
</tr>
</table>
</details>
<details>
<summary>rename <progress value='18' max='25'></progress></summary>
<table>
<tr>
<th>Test</th>
<th>Description</th>
<th>Converted</th>
</tr>
<tr>
<td>00.t</td>
<td>rename changes file name
</td>
<td>Yes</td>
</tr>
<tr>
<td>01.t</td>
<td>rename returns ENAMETOOLONG if a component of either pathname exceeded {NAME_MAX} characters
</td>
<td>Yes</td>
</tr>
<tr>
<td>02.t</td>
<td>rename returns ENAMETOOLONG if an entire length of either path name exceeded {PATH_MAX} characters
</td>
<td>Yes</td>
</tr>
<tr>
<td>03.t</td>
<td>rename returns ENOENT if a component of the 'from' path does not exist, or a path prefix of 'to' does not exist
</td>
<td>Yes</td>
</tr>
<tr>
<td>04.t</td>
<td>rename returns EACCES when a component of either path prefix denies search permission
</td>
<td>No</td>
</tr>
<tr>
<td>05.t</td>
<td>rename returns EACCES when the requested link requires writing in a directory with a mode that denies write permission
</td>
<td>No</td>
</tr>
<tr>
<td>06.t</td>
<td>rename returns EPERM if the file pointed at by the 'from' argument has its immutable, undeletable or append-only flag set
</td>
<td>No</td>
</tr>
<tr>
<td>07.t</td>
<td>rename returns EPERM if the parent directory of the file pointed at by the 'from' argument has its immutable or append-only flag set
</td>
<td>No</td>
</tr>
<tr>
<td>08.t</td>
<td>rename returns EPERM if the parent directory of the file pointed at by the 'to' argument has its immutable flag set
</td>
<td>No</td>
</tr>
<tr>
<td>09.t</td>
<td>rename returns EACCES or EPERM if the directory containing 'from' is marked sticky, and neither the containing directory nor 'from' are owned by the effective user ID
</td>
<td>No</td>
</tr>
<tr>
<td>10.t</td>
<td>rename returns EACCES or EPERM if the file pointed at by the 'to' argument exists, the directory containing 'to' is marked sticky, and neither the containing directory nor 'to' are owned by the effective user ID
</td>
<td>No</td>
</tr>
<tr>
<td>11.t</td>
<td>rename returns ELOOP if too many symbolic links were encountered in translating one of the pathnames
</td>
<td>Yes</td>
</tr>
<tr>
<td>12.t</td>
<td>rename returns ENOTDIR if a component of either path prefix is not a directory
</td>
<td>Yes</td>
</tr>
<tr>
<td>13.t</td>
<td>rename returns ENOTDIR when the 'from' argument is a directory, but 'to' is not a directory
</td>
<td>Yes</td>
</tr>
<tr>
<td>14.t</td>
<td>rename returns EISDIR when the 'to' argument is a directory, but 'from' is not a directory
</td>
<td>Yes</td>
</tr>
<tr>
<td>15.t</td>
<td>rename returns EXDEV if the link named by 'to' and the file named by 'from' are on different file systems
</td>
<td>Yes</td>
</tr>
<tr>
<td>16.t</td>
<td>rename returns EROFS if the requested link requires writing in a directory on a read-only file system
</td>
<td>Yes</td>
</tr>
<tr>
<td>17.t</td>
<td>rename returns EFAULT if one of the pathnames specified is outside the process's allocated address space
</td>
<td>Yes</td>
</tr>
<tr>
<td>18.t</td>
<td>rename returns EINVAL when the 'from' argument is a parent directory of 'to'
</td>
<td>Yes</td>
</tr>
<tr>
<td>19.t</td>
<td>rename returns EINVAL/EBUSY when an attempt is made to rename '.' or '..'
</td>
<td>Yes</td>
</tr>
<tr>
<td>20.t</td>
<td>rename returns EEXIST or ENOTEMPTY if the 'to' argument is a directory and is not empty
</td>
<td>Yes</td>
</tr>
<tr>
<td>21.t</td>
<td>write access to subdirectory is required to move it to another directory
</td>
<td>Yes</td>
</tr>
<tr>
<td>22.t</td>
<td>rename changes file ctime
</td>
<td>Yes</td>
</tr>
<tr>
<td>23.t</td>
<td>rename succeeds when to is multiply linked
</td>
<td>Yes</td>
</tr>
<tr>
<td>24.t</td>
<td>rename of a directory updates its .. link
</td>
<td>Yes</td>
</tr>
</table>
</details>
<details>
<summary>rmdir <progress value='11' max='16'></progress></summary>
<table>
<tr>
<th>Test</th>
<th>Description</th>
<th>Converted</th>
</tr>
<tr>
<td>00.t</td>
<td>rmdir removes directories
</td>
<td>Yes</td>
</tr>
<tr>
<td>01.t</td>
<td>rmdir returns ENOTDIR if a component of the path is not a directory
</td>
<td>Yes</td>
</tr>
<tr>
<td>02.t</td>
<td>rmdir returns ENAMETOOLONG if a component of a pathname exceeded {NAME_MAX} characters
</td>
<td>Yes</td>
</tr>
<tr>
<td>03.t</td>
<td>rmdir returns ENAMETOOLONG if an entire path name exceeded ${PATH_MAX} characters
</td>
<td>Yes</td>
</tr>
<tr>
<td>04.t</td>
<td>rmdir returns ENOENT if the named directory does not exist
</td>
<td>Yes</td>
</tr>
<tr>
<td>05.t</td>
<td>rmdir returns ELOOP if too many symbolic links were encountered in translating the pathname
</td>
<td>Yes</td>
</tr>
<tr>
<td>06.t</td>
<td>rmdir returns EEXIST or ENOTEMPTY the named directory contains files other than '.' and '..' in it
</td>
<td>Yes</td>
</tr>
<tr>
<td>07.t</td>
<td>rmdir returns EACCES when search permission is denied for a component of the path prefix
</td>
<td>No</td>
</tr>
<tr>
<td>08.t</td>
<td>rmdir returns EACCES when write permission is denied on the directory containing the link to be removed
</td>
<td>No</td>
</tr>
<tr>
<td>09.t</td>
<td>rmdir returns EPERM if the named directory has its immutable, undeletable or append-only flag set
</td>
<td>No</td>
</tr>
<tr>
<td>10.t</td>
<td>rmdir returns EPERM if the parent directory of the named file has its immutable or append-only flag set
</td>
<td>No</td>
</tr>
<tr>
<td>11.t</td>
<td>rmdir returns EACCES or EPERM if the directory containing the directory to be removed is marked sticky, and neither the containing directory nor the directory to be removed are owned by the effective user ID
</td>
<td>No</td>
</tr>
<tr>
<td>12.t</td>
<td>rmdir returns EINVAL if the last component of the path is '.' and EEXIST or ENOTEMPTY if the last component of the path is '..'
</td>
<td>Yes</td>
</tr>
<tr>
<td>13.t</td>
<td>rmdir returns EBUSY if the directory to be removed is the mount point for a mounted file system
</td>
<td>Yes</td>
</tr>
<tr>
<td>14.t</td>
<td>rmdir returns EROFS if the named file resides on a read-only file system
</td>
<td>Yes</td>
</tr>
<tr>
<td>15.t</td>
<td>rmdir returns EFAULT if the path argument points outside the process's allocated address space
</td>
<td>Yes</td>
</tr>
</table>
</details>
<details>
<summary>symlink <progress value='8' max='13'></progress></summary>
<table>
<tr>
<th>Test</th>
<th>Description</th>
<th>Converted</th>
</tr>
<tr>
<td>00.t</td>
<td>symlink creates symbolic links
</td>
<td>Yes</td>
</tr>
<tr>
<td>01.t</td>
<td>symlink returns ENOTDIR if a component of the name2 path prefix is not a directory
</td>
<td>Yes</td>
</tr>
<tr>
<td>02.t</td>
<td>symlink returns ENAMETOOLONG if a component of the name2 pathname exceeded {NAME_MAX} characters
</td>
<td>Yes</td>
</tr>
<tr>
<td>03.t</td>
<td>symlink returns ENAMETOOLONG if an entire length of either path name exceeded {PATH_MAX} characters
</td>
<td>Yes</td>
</tr>
<tr>
<td>04.t</td>
<td>symlink returns ENOENT if a component of the name2 path prefix does not exist
</td>
<td>Yes</td>
</tr>
<tr>
<td>05.t</td>
<td>symlink returns EACCES when a component of the name2 path prefix denies search permission
</td>
<td>No</td>
</tr>
<tr>
<td>06.t</td>
<td>symlink returns EACCES if the parent directory of the file to be created denies write permission
</td>
<td>No</td>
</tr>
<tr>
<td>07.t</td>
<td>symlink returns ELOOP if too many symbolic links were encountered in translating the name2 path name
</td>
<td>No</td>
</tr>
<tr>
<td>08.t</td>
<td>symlink returns EEXIST if the name2 argument already exists
</td>
<td>Yes</td>
</tr>
<tr>
<td>09.t</td>
<td>symlink returns EPERM if the parent directory of the file named by name2 has its immutable flag set
</td>
<td>No</td>
</tr>
<tr>
<td>10.t</td>
<td>symlink returns EROFS if the file name2 would reside on a read-only file system
</td>
<td>Yes</td>
</tr>
<tr>
<td>11.t</td>
<td>symlink returns ENOSPC if there are no free inodes on the file system on which the symbolic link is being created
</td>
<td>No</td>
</tr>
<tr>
<td>12.t</td>
<td>symlink returns EFAULT if one of the pathnames specified is outside the process's allocated address space
</td>
<td>Yes</td>
</tr>
</table>
</details>
<details>
<summary>truncate <progress value='11' max='15'></progress></summary>
<table>
<tr>
<th>Test</th>
<th>Description</th>
<th>Converted</th>
</tr>
<tr>
<td>00.t</td>
<td>truncate descrease/increase file size
</td>
<td>Yes</td>
</tr>
<tr>
<td>01.t</td>
<td>truncate returns ENOTDIR if a component of the path prefix is not a directory
</td>
<td>Yes</td>
</tr>
<tr>
<td>02.t</td>
<td>truncate returns ENAMETOOLONG if a component of a pathname exceeded {NAME_MAX} characters
</td>
<td>Yes</td>
</tr>
<tr>
<td>03.t</td>
<td>truncate returns ENAMETOOLONG if an entire path name exceeded {PATH_MAX} characters
</td>
<td>Yes</td>
</tr>
<tr>
<td>04.t</td>
<td>truncate returns ENOENT if the named file does not exist
</td>
<td>Yes</td>
</tr>
<tr>
<td>05.t</td>
<td>truncate returns EACCES when search permission is denied for a component of the path prefix
</td>
<td>No</td>
</tr>
<tr>
<td>06.t</td>
<td>truncate returns EACCES if the named file is not writable by the user
</td>
<td>No</td>
</tr>
<tr>
<td>07.t</td>
<td>truncate returns ELOOP if too many symbolic links were encountered in translating the pathname
</td>
<td>Yes</td>
</tr>
<tr>
<td>08.t</td>
<td>truncate returns EPERM if the named file has its immutable or append-only flag set
</td>
<td>No</td>
</tr>
<tr>
<td>09.t</td>
<td>truncate returns EISDIR if the named file is a directory
</td>
<td>Yes</td>
</tr>
<tr>
<td>10.t</td>
<td>truncate returns EROFS if the named file resides on a read-only file system
</td>
<td>Yes</td>
</tr>
<tr>
<td>11.t</td>
<td>truncate returns ETXTBSY the file is a pure procedure (shared text) file that is being executed
</td>
<td>Yes</td>
</tr>
<tr>
<td>12.t</td>
<td>truncate returns EFBIG or EINVAL if the length argument was greater than the maximum file size
</td>
<td>No</td>
</tr>
<tr>
<td>13.t</td>
<td>truncate returns EINVAL if the length argument was less than 0
</td>
<td>Yes</td>
</tr>
<tr>
<td>14.t</td>
<td>truncate returns EFAULT if the path argument points outside the process's allocated address space
</td>
<td>Yes</td>
</tr>
</table>
</details>
<details>
<summary>unlink <progress value='9' max='15'></progress></summary>
<table>
<tr>
<th>Test</th>
<th>Description</th>
<th>Converted</th>
</tr>
<tr>
<td>00.t</td>
<td>unlink removes regular files, symbolic links, fifos and sockets
</td>
<td>Yes</td>
</tr>
<tr>
<td>01.t</td>
<td>unlink returns ENOTDIR if a component of the path prefix is not a directory
</td>
<td>Yes</td>
</tr>
<tr>
<td>02.t</td>
<td>unlink returns ENAMETOOLONG if a component of a pathname exceeded {NAME_MAX} characters
</td>
<td>Yes</td>
</tr>
<tr>
<td>03.t</td>
<td>unlink returns ENAMETOOLONG if an entire path name exceeded {PATH_MAX} characters
</td>
<td>Yes</td>
</tr>
<tr>
<td>04.t</td>
<td>unlink returns ENOENT if the named file does not exist
</td>
<td>Yes</td>
</tr>
<tr>
<td>05.t</td>
<td>unlink returns EACCES when search permission is denied for a component of the path prefix
</td>
<td>No</td>
</tr>
<tr>
<td>06.t</td>
<td>unlink returns EACCES when write permission is denied on the directory containing the link to be removed
</td>
<td>No</td>
</tr>
<tr>
<td>07.t</td>
<td>unlink returns ELOOP if too many symbolic links were encountered in translating the pathname
</td>
<td>Yes</td>
</tr>
<tr>
<td>08.t</td>
<td>unlink may return EPERM if the named file is a directory
</td>
<td>No</td>
</tr>
<tr>
<td>09.t</td>
<td>unlink returns EPERM if the named file has its immutable, undeletable or append-only flag set
</td>
<td>No</td>
</tr>
<tr>
<td>10.t</td>
<td>unlink returns EPERM if the parent directory of the named file has its immutable or append-only flag set
</td>
<td>No</td>
</tr>
<tr>
<td>11.t</td>
<td>unlink returns EACCES or EPERM if the directory containing the file is marked sticky, and neither the containing directory nor the file to be removed are owned by the effective user ID
</td>
<td>No</td>
</tr>
<tr>
<td>12.t</td>
<td>unlink returns EROFS if the named file resides on a read-only file system
</td>
<td>Yes</td>
</tr>
<tr>
<td>13.t</td>
<td>unlink returns EFAULT if the path argument points outside the process's allocated address space
</td>
<td>Yes</td>
</tr>
<tr>
<td>14.t</td>
<td>An open file will not be immediately freed by unlink
</td>
<td>Yes</td>
</tr>
</table>
</details>
<details>
<summary>utimensat <progress value='10' max='10'></progress></summary>
<table>
<tr>
<th>Test</th>
<th>Description</th>
<th>Converted</th>
</tr>
<tr>
<td>00.t</td>
<td>utimensat changes timestamps on any type of file
</td>
<td>Yes</td>
</tr>
<tr>
<td>01.t</td>
<td>utimensat with UTIME_NOW will set the will set typestamps to now
</td>
<td>Yes</td>
</tr>
<tr>
<td>02.t</td>
<td>utimensat with UTIME_OMIT will leave the time unchanged
</td>
<td>Yes</td>
</tr>
<tr>
<td>03.t</td>
<td>utimensat can update birthtimes
</td>
<td>Yes</td>
</tr>
<tr>
<td>04.t</td>
<td>utimensat can set mtime < atime or vice versa
</td>
<td>Yes</td>
</tr>
<tr>
<td>05.t</td>
<td>utimensat can follow symlinks
</td>
<td>Yes</td>
</tr>
<tr>
<td>06.t</td>
<td>utimensat with UTIME_NOW will work if the caller has write permission
</td>
<td>Yes</td>
</tr>
<tr>
<td>07.t</td>
<td>utimensat will work if the caller is the owner or root
</td>
<td>Yes</td>
</tr>
<tr>
<td>08.t</td>
<td>utimensat can set timestamps with subsecond precision
</td>
<td>Yes</td>
</tr>
<tr>
<td>09.t</td>
<td>utimensat is y2038 compliant
</td>
<td>Yes</td>
</tr>
</table>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="configuration-file"><a class="header" href="#configuration-file">Configuration file</a></h1>
<p>The test runner can read a configuration file. For now, only the TOML format is supported.
Its path can be specified by using the <code>-c PATH</code> flag.</p>
<h2 id="sections"><a class="header" href="#sections">Sections</a></h2>
<h3 id="features"><a class="header" href="#features">[features]</a></h3>
<p>Some features are not available for every file system.
For tests requiring such features,
the execution becomes opt-in.
The user can enable their execution,
by adding the corresponding feature as a key in this section.
A list of these opt-in features is provided
when executing the runner with <code>-l</code> argument.</p>
<p>For example, with <code>posix_fallocate</code>:</p>
<pre><code class="language-toml">[features]
posix_fallocate = {}

# Can also be specified by using key notation
# [features.posix_fallocate]
</code></pre>
<h4 id="feature-list"><a class="header" href="#feature-list">Feature list</a></h4>
<p>The following features can be enabled but do not require any additional configuration:</p>
<ul>
<li><strong>chflags</strong> - The <a href="https://man.freebsd.org/cgi/man.cgi?chflags(1)"><code>chflags</code></a> syscall is available</li>
<li><strong>nfsv4_acls</strong> - NFSv4 style Access Control Lists are available</li>
<li><strong>posix_fallocate</strong> - The <a href="https://pubs.opengroup.org/onlinepubs/007904975/functions/posix_fallocate.html"><code>posix_fallocate</code></a> syscall is available</li>
<li><strong>rename_ctime</strong> - <a href="https://pubs.opengroup.org/onlinepubs/9699919799/functions/rename.html"><code>rename</code></a> changes <code>st_ctime</code> on success (POSIX does not require a file system to update a file's ctime when it gets renamed, but some file systems choose to do it anyway)</li>
<li><strong>stat_st_birthtime</strong> - <code>struct stat</code> contains an <a href="https://man.freebsd.org/cgi/man.cgi?stat(2)"><code>st_birthtime</code></a> field</li>
<li><strong>chflags_sf_snapshot</strong> - The <a href="https://man.freebsd.org/cgi/man.cgi?chflags(2)"><code>SF_SNAPSHOT</code></a> flag can be set with <code>chflags</code></li>
<li><strong>utime_now</strong> - The <a href="https://pubs.opengroup.org/onlinepubs/9699919799.orig/functions/futimens.html"><code>UTIME_NOW</code></a> constant is available</li>
<li><strong>utimensat</strong> - The <a href="https://pubs.opengroup.org/onlinepubs/9699919799.orig/functions/utimensat.html"><code>utimensat</code></a> syscall is available</li>
</ul>
<p>Following features require additional configuration.</p>
<h4 id="file_flags"><a class="header" href="#file_flags">file_flags</a></h4>
<p>Some tests are related to file flags.
However, not all file systems and operating systems support all flags.
To give a sufficient level of granularity, each supported flag can be
specified in the configuration with the <code>file_flags</code> array.</p>
<pre><code class="language-toml">[features]
posix_fallocate = {}
file_flags = ["UF_IMMUTABLE"]
</code></pre>
<h4 id="secondary_fs"><a class="header" href="#secondary_fs">secondary_fs</a></h4>
<p>Some tests require a secondary file system.
This can be specified in the configuration with the <code>secondary_fs</code> key,
but also with the <code>secondary_fs</code> argument.
The argument takes precedence over the configuration.</p>
<pre><code class="language-toml">[features]
secondary_fs = "/mnt/ISO"
</code></pre>
<h3 id="dummy_auth"><a class="header" href="#dummy_auth">[dummy_auth]</a></h3>
<p>This section allows to modify the mechanism for switching users, which is required by some tests.</p>
<pre><code class="language-toml">[dummy_auth]
entries = [
  ["nobody", "nobody"],
  # nogroup instead for some Linux distros
  # ["nobody", "nogroup"],
  ["tests", "tests"],
  ["pjdfstest", "pjdfstest"],
]
</code></pre>
<ul>
<li><code>entries</code> - An entry is composed of a username and its associated group.
Exactly 3 entries need to be specified if the default ones cannot be used.</li>
</ul>
<h3 id="settings"><a class="header" href="#settings">[settings]</a></h3>
<pre><code class="language-toml">[settings]
naptime = 0.001
allow_remount = false
</code></pre>
<ul>
<li><code>naptime</code> - The duration for a "short" sleep. It should be greater than the
timestamp granularity of the file system under test. The default value is 1
second.</li>
<li><code>allow_remount</code> - If set to <code>true</code>, the runner will run the EROFS tests,
which require to remount the file system on which
pjdsfstest is run as read-only.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="structure"><a class="header" href="#structure">Structure</a></h1>
<p>The package is made of the tests, and a test runner to launch them.</p>
<h2 id="tests-tests"><a class="header" href="#tests-tests">Tests (tests/)</a></h2>
<p>To present how tests are organized, we take the <code>chmod</code> syscall as example.</p>
<p>There is a separate module for each syscall being tested. Within each of those
modules, there may be either a single file, or a separate file for each aspect
of the syscall.</p>
<p>The hierarchy is like this:</p>
<pre class="mermaid">graph TD
TG[Syscall module&lt;br /&gt;&lt;i&gt;chmod&lt;/i&gt;] --&gt; TC1[Aspect&lt;br /&gt;&lt;i&gt;errno&lt;/i&gt;]

TC1 --&gt; TC1F1[Test case]
TC1 --&gt; TC1F2[Test case]
TC1 --&gt; TC1F3[Test case]
TC1 --&gt; TC1F4[Test case]

TG --&gt; TC2[Aspect&lt;br /&gt;&lt;i&gt;permission&lt;/i&gt;]

TC2 --&gt; TC2F1[Test case]
TC2 --&gt; TC2F2[Test case]
</pre>
<h3 id="layout"><a class="header" href="#layout">Layout</a></h3>
<pre><code class="language-bash">src/tests
├── chmod (syscall)
│   ├── errno.rs (aspect)
│   └── permission.rs (aspect)
├── mod.rs (glues syscalls together)
└── chmod.rs (syscall declaration and simple test cases)
</code></pre>
<h4 id="testsmodrs"><a class="header" href="#testsmodrs">tests/mod.rs</a></h4>
<p>All the modules for the test groups should be declared in this file.</p>
<pre><code class="language-rust ignore">pub mod chmod;</code></pre>
<h2 id="syscall-module"><a class="header" href="#syscall-module">Syscall module</a></h2>
<p>A syscall module contains test cases related to a specific syscall.
Its declaration should be in the <code>&lt;syscall_name&gt;.rs</code> file at the root of the
<code>tests/</code> directory.
Common syscall-specific helpers can go here.</p>
<h3 id="aspect"><a class="header" href="#aspect">Aspect</a></h3>
<p>An optional aspect module contains test cases that all relate to a common
aspect of the syscall.
Here "aspect" is a subjective area of related functionality.
The aspect module may be either:</p>
<ul>
<li>in a single file, which contains all the test functions,</li>
<li>in a folder, which contains multiple modules for the test functions, in which the case is declared.</li>
</ul>
<p>Except in the case of a very large set of test functions, the first style
should be preferred.</p>
<h3 id="test-case"><a class="header" href="#test-case">Test case</a></h3>
<p>Each test case exercises a minimal piece of the syscall's functionality.
Each must be registered with the <code>test_case!</code> macro.</p>
<pre><code class="language-rust ignore">crate::test_case! {
    /// open do not update parent directory ctime and mtime fields if
    /// the file previously existed.
    exists_no_update
}
fn exists_no_update(ctx: &amp;mut TestContext) {
    let file = ctx.create(FileType::Regular).unwrap();

    assert_times_unchanged()
        .path(ctx.base_path(), CTIME | MTIME)
        .execute(ctx, false, || {
            assert!(open_wrapper(&amp;file, Mode::from_bits_truncate(0o755)).is_ok());
        });
}</code></pre>
<h2 id="test-runner-mainrs"><a class="header" href="#test-runner-mainrs">Test runner (main.rs)</a></h2>
<p>The test runner has to run the tests, and provide a command-line interface to allow the user to modify how the tests should be run.
It takes the tests from the specified test groups.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="test-declaration"><a class="header" href="#test-declaration">Test declaration</a></h1>
<p>Test cases have the same structure than usual Rust tests,
that is <code>unwrap</code>ing <code>Result</code>s and using assertion macros (<code>assert</code> and <code>assert_eq</code>),
the exception being that it should take a <code>&amp;mut TestContext</code> parameter.
It might also take a <code>FileType</code> argument if required.
It also needs an additional declaration with the <code>test_case!</code> macro alongside the function,
with the function name being the only mandatory argument.</p>
<p>For example:</p>
<pre><code class="language-rust ignore">// chmod/00.t:L58
crate::test_case! {
    /// chmod updates ctime when it succeeds
    update_ctime =&gt; [Regular, Dir, Fifo, Block, Char, Socket]
}
fn update_ctime(ctx: &amp;mut TestContext, f_type: FileType) {
    let path = ctx.create(f_type).unwrap();
    assert_ctime_changed(ctx, &amp;path, || {
        assert!(chmod(&amp;path, Mode::from_bits_truncate(0o111)).is_ok());
    });
}</code></pre>
<p>All the structures and functions needed are documented in the <code>pjdfstest</code> crate,
which you can obtain by running <code>cargo doc --open</code> in the <code>rust</code> directory
or by visiting the <a href="doc/pjdfstest/">documentation</a>.</p>
<h2 id="test-context"><a class="header" href="#test-context">Test context</a></h2>
<p>The <a href="doc/pjdfstest/context/struct.TestContext.html"><code>TestContext</code></a>
struct is a helper struct which provides methods to create files,
sleep, change user, etc.
It is passed as a parameter to the test functions and should be used
to interact with the system in order to ensure that the tests are isolated
and do not interfere with each other.</p>
<h3 id="serialization"><a class="header" href="#serialization">Serialization</a></h3>
<p>When a test case needs to be run in a serialized manner, the
<a href="doc/pjdfstest/context/struct.SerializedTestContext.html"><code>SerializedTestContext</code></a>
struct should be used instead.
It provides additional methods to change the user, group,
supplementary groups, or umask of the process.
Please see the <a href="test-declaration.html#serialized-test-cases">Serialized test cases</a> section for more information.</p>
<h2 id="assertions"><a class="header" href="#assertions">Assertions</a></h2>
<p>The <code>assert</code> and <code>assert_eq</code> macros should be used to check the results of the tests.
The <code>assert</code> macro should be used when the test is checking a condition,
while the <code>assert_eq</code> macro should be used when the test is checking
that two values are equal.
In addition to these macros, the suite provides some additional assertion functions which
should be used when appropriate.
The tests <a href="doc/pjdfstest/tests/index.html#functions">module</a> documentation provides
a list of these functions.</p>
<h2 id="description"><a class="header" href="#description">Description</a></h2>
<p>It is possible to provide doc comments which will be used as documentation for developers
but also be displayed to users when they run the test.
The doc comments should be written in the <code>test_case!</code> declaration, before anything.
For example:</p>
<pre><code class="language-rust ignore">crate::test_case! {
    /// The file mode of a newly created file should not affect whether
    /// posix_fallocate will work, only the create args
    /// https://bugs.freebsd.org/bugzilla/show_bug.cgi?id=154873
    affected_only_create_flags, serialized, root, FileSystemFeature::PosixFallocate
}</code></pre>
<h2 id="parameterization"><a class="header" href="#parameterization">Parameterization</a></h2>
<p>It is possible to give additional parameters to the test case macro,
to modify the execution of the tests or add requirements.</p>
<h3 id="file-system-exclusive-features"><a class="header" href="#file-system-exclusive-features">File-system exclusive features</a></h3>
<p>Some features are not available for every file system.
For tests requiring such features, the execution becomes opt-in.
A variant of the <code>FileSystemFeature</code> enum corresponding to this feature
should be specified after potential <code>root</code> requirement and before guards.
Multiple features can be specified, separated by a comma <code>,</code>.</p>
<p>For example:</p>
<pre><code class="language-rust ignore">#[cfg(target_os = "freebsd")]
crate::test_case! {eperm_immutable_flag, FileSystemFeature::Chflags, FileSystemFeature::PosixFallocate ...}</code></pre>
<h4 id="adding-features"><a class="header" href="#adding-features">Adding features</a></h4>
<p>New features can be added to the <code>FileSystemFeature</code> enum.
A description of the feature should be provided as documentation
for both developers and users.</p>
<h3 id="guards"><a class="header" href="#guards">Guards</a></h3>
<p>It is possible to specify "guards", which are functions which checks if a requirement
is met and return an error if not so the test will be skipped.
They can be specified by appending function names after a <code>;</code> separator,
after potential <code>root</code> requirement and features.</p>
<p>The function has to take a <code>&amp;Config</code> argument
which contains the current configuration
and a <code>&amp;Path</code> which represents the parent folder
of the potential test context which would be created.</p>
<h4 id="guard-signature"><a class="header" href="#guard-signature">Guard signature</a></h4>
<pre><code class="language-rust ignore">/// Function which indicates if the test should be skipped by returning an error.
pub type Guard = fn(&amp;Config, &amp;Path) -&gt; anyhow::Result&lt;()&gt;;</code></pre>
<h4 id="example"><a class="header" href="#example">Example</a></h4>
<pre><code class="language-rust ignore">fn has_reasonable_link_max(_: &amp;Config, base_path: &amp;Path) -&gt; anyhow::Result&lt;()&gt; {
    let link_max = pathconf(base_path, nix::unistd::PathconfVar::LINK_MAX)?
        .ok_or_else(|| anyhow::anyhow!("Failed to get LINK_MAX value"))?;

    if link_max &gt;= LINK_MAX_LIMIT {
        anyhow::bail!("LINK_MAX value is too high ({link_max}, expected smaller than {LINK_MAX_LIMIT}");
    }

    Ok(())
}

crate::test_case! {
    /// link returns EMLINK if the link count of the file named by name1 would exceed {LINK_MAX}
    link_count_max; has_reasonable_link_max
}
...</code></pre>
<h3 id="root-privileges"><a class="header" href="#root-privileges">Root privileges</a></h3>
<p>Some tests may need root privileges to run.
To declare that a test function require such privileges,
<code>root</code> should be added to its declaration.
For example:</p>
<pre><code class="language-rust ignore">crate::test_case!{change_perm, root}</code></pre>
<p>The root requirement is automatically added for privileged file types,
namely block and char.</p>
<h3 id="file-types"><a class="header" href="#file-types">File types</a></h3>
<p>Some test cases need to test over different file types.
The file types should be added at the end of the test case declaration,
within brackets and with a fat arrow before (<code>=&gt; [Regular]</code>).
The test function should also accept a <code>FileType</code> parameter to operate on.</p>
<p>For example:</p>
<pre><code class="language-rust ignore">crate::test_case! {change_perm, root, FileSystemFeature::Chflags =&gt; [Regular, Fifo, Block, Char, Socket]}
fn change_perm(ctx: &amp;mut TestContext, f_type: FileType) {</code></pre>
<h2 id="platform-specific-features"><a class="header" href="#platform-specific-features">Platform-specific features</a></h2>
<p>Some features (like <code>lchmod</code>) are not supported on every operating system.
When a test make use of such feature, it is possible to restrain its compilation
to the supported operating systems, with the attribute <code>#[cfg(feature_name)]</code>.
It is also possible to apply this attribute on an aspect or even a syscall module.
For example:</p>
<pre><code class="language-rust ignore">#[cfg(lchmod)]
mod lchmod;</code></pre>
<p>To declare it, the feature and its requirements have to be specified in the <code>build.rs</code> file
using the usual conditional compilation
<a href="https://doc.rust-lang.org/reference/conditional-compilation.html">syntax</a>.
Then, the feature should be added to the <code>cfg_aliases!</code> macro.
With <code>lchmod</code>, we would get:</p>
<pre><code class="language-rust ignore">    cfg_aliases! {
        ...
        lchmod: { any(target_os = "netbsd", target_os = "freebsd", target_os = "dragonfly") },
        ...
    }</code></pre>
<h2 id="serialized-test-cases"><a class="header" href="#serialized-test-cases">Serialized test cases</a></h2>
<p>Some test cases need functions only available when they are run serialized,
especially when they affect the whole process.
An example is changing user (<code>SerializedTestContext::as_user</code>).
To have access to these functions, the test should be declared with a
<a href="doc/pjdfstest/context/struct.SerializedTestContext.html"><code>SerializedTestContext</code></a>
parameter in place of <code>TestContext</code> and the <code>serialized</code> keyword
should be prepended before features and <code>root</code> requirement.</p>
<p>For example:</p>
<pre><code class="language-rust ignore">crate::test_case! {
    /// link changes neither ctime of file nor ctime or mtime of parent when it fails
    // link/00.t#77
    unchanged_ctime_fails, serialized, root =&gt; [Regular, Fifo, Block, Char, Socket]
}
fn unchanged_ctime_fails(ctx: &amp;mut SerializedTestContext, ft: FileType) {
    let file = ctx.create(ft).unwrap();
    let new_path = ctx.gen_path();

    let user = ctx.get_new_user();
    assert_times_unchanged()
        .path(&amp;file, CTIME)
        .path(ctx.base_path(), CTIME | MTIME)
        .execute(ctx, false, || {
            ctx.as_user(user, None, || {
                assert!(matches!(
                    link(&amp;file, &amp;new_path),
                    Err(Errno::EPERM | Errno::EACCES)
                ));
            })
        });
}</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="mermaid.min.js"></script>
        <script src="mermaid-init.js"></script>

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
